<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arcade Claw (3 Tries)</title>
<style>
  html,body{
    height:100%;
    margin:0;
    background:#05060b;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
    color:#e5e7eb;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  #wrap{ display:flex; gap:16px; }
  canvas{
    border-radius:18px;
    box-shadow:0 0 30px rgba(120,180,255,.22), 0 0 90px rgba(255,80,200,.10);
    background:#0b1022;
  }
  .panel{
    width:300px;
    padding:18px;
    border-radius:18px;
    background: rgba(15,23,42,.82);
    box-shadow:0 0 20px rgba(120,180,255,.12);
  }
  .panel h2{
    margin:0 0 12px 0;
    font-size:18px;
    color:#93c5fd;
    display:flex; align-items:center; gap:8px;
  }
  .card{
    padding:12px;
    border-radius:14px;
    background: rgba(30,41,59,.55);
    margin-bottom:10px;
    border:1px solid rgba(148,163,184,.18);
  }
  .muted{ color: rgba(226,232,240,.75); font-size:13px; }
  .kbd{
    display:inline-block;
    padding:2px 8px;
    border-radius:8px;
    background: rgba(2,6,23,.55);
    border:1px solid rgba(148,163,184,.25);
    font-weight:700;
    font-size:12px;
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c" width="980" height="660"></canvas>

  <div class="panel">
    <h2>ğŸ¯ ì¸í˜•ë½‘ê¸° ë°©ë²•</h2>

    <div class="card">
      <b>1. ì´ë™</b><br>
      <span class="kbd">â†</span> <span class="kbd">â†’</span> ë¡œ ì§‘ê²Œ ìœ„ì¹˜ë¥¼ ì¡°ì ˆí•©ë‹ˆë‹¤.
    </div>

    <div class="card">
      <b>2. ë‚´ë ¤ê°€ê¸°</b><br>
      <span class="kbd">Space</span> 1ë²ˆ â†’ ì§‘ê²Œê°€ ë‚´ë ¤ê°‘ë‹ˆë‹¤.
      <div class="muted">ì›í•˜ëŠ” ë†’ì´ì—ì„œ ë‹¤ì‹œ Spaceë¥¼ ëˆ„ë¥´ì„¸ìš”.</div>
    </div>

    <div class="card">
      <b>3. ì¡ê¸°</b><br>
      <span class="kbd">Space</span> 2ë²ˆ â†’ ê·¸ ìë¦¬ì—ì„œ ì§‘ê²Œê°€ ë‹«íˆë©° ì¸í˜•ì„ ì§‘ìŠµë‹ˆë‹¤.
      <div class="muted">í™”ë©´ ì¢Œìƒë‹¨ì— â€œíŒì •%â€ê°€ ëœ¹ë‹ˆë‹¤.</div>
    </div>

    <div class="card">
      <b>ê·œì¹™</b><br>
      âœ” í•™ìƒ 1ëª…ë‹¹ 3ë²ˆ ë„ì „<br>
      âœ” ì„±ê³µ ì‹œ 1ê°œ ì§€ê¸‰ í›„ ì¢…ë£Œ<br>
      âœ” <b>RESET</b> ë²„íŠ¼ìœ¼ë¡œ ë‹¤ìŒ í•™ìƒ
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  const rand = (a,b)=>Math.random()*(b-a)+a;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  // ===== Field =====
  const box = { x: 70, y: 90, w: 760, h: 500 };
  const floorY = box.y + box.h;

  // ===== UI Button (inside canvas) =====
  const btn = { x: W/2 - 130, y: H - 78, w: 260, h: 48 };

  // ===== Config =====
  const cfg = {
    triesPerStudent: 3,

    moveSpeed: 5,
    ropeSpeed: 5,

    // 2-press control: ë‚´ë ¤ê°€ëŠ” ìµœëŒ€ ê¹Šì´(ì•ˆì „ì¥ì¹˜)
    maxDepth: box.h - 110,

    // claw animation
    openAngle: 0.88,
    closedAngle: 0.12,
    animLerp: 0.16,

    // catch probability
    baseGrip: 0.78,
    distPenalty: 0.65,
    weightPenalty: 0.35,
    grabRadiusPad: 40,

    // slip while lifting
    slipBase: 0.005,
    slipWiggle: 0.010,
    slipKickX: 2.0,

    // physics for falling dolls
    g: 0.42,
    air: 0.992,
    bounce: 0.20,
    groundFriction: 0.84,
    collidePush: 0.45,   // ë„ˆë¬´ ì„¸ë©´ íŠ€ì–´ë‚˜ê°€ë¯€ë¡œ ì‚´ì§ ë‚®ì¶¤
    maxV: 16,
  };

  // ===== State =====
  const state = {
    triesLeft: cfg.triesPerStudent,
    phase: "play", // play | won | done
    msg: "",
    msgT: 180,
    lastP: 0,
    shake: 0,
    prize: null,

    // ì¡ê¸° íŒì • í‘œì‹œìš©
    aim: { x: 0, y: 0, r: 0, idx: null, p: 0, flash: 0, result: "" } // result: "OK"/"NO"
  };

  // ===== Claw =====
  const claw = {
    x: box.x + box.w/2,
    railY: box.y - 26,
    rope: 0,
    mode: "idle", // idle | downHold | grabbing | up | opening
    armAngle: cfg.openAngle,
    targetAngle: cfg.openAngle,
    holding: null, // doll index
    wiggle: 0,
  };

  // ===== Dolls =====
  const dolls = [];

  function makePile(n=95){
    dolls.length = 0;
    const left = box.x + 34;
    const right = box.x + box.w - 34;
    const pileTop = box.y + box.h*0.55;
    const bottom = floorY - 18;

    const cols = 22;
    const rows = 6;

    const cellW = (right - left) / cols;
    const cellH = (bottom - pileTop) / rows;

    let made = 0;
    for(let ry=0; ry<rows && made<n; ry++){
      for(let cx=0; cx<cols && made<n; cx++){
        const r = clamp(rand(14, 24), 14, 24);
        const x = left + cx*cellW + cellW/2 + rand(-8, 8);
        const y = bottom - ry*cellH - r + rand(-6, 6);
        const weight = clamp(0.55 + (r-14)*0.04 + ry*0.10, 0.5, 1.5);
        const hue = Math.floor(rand(190, 340));
        dolls.push({
          x, y, r, weight,
          color: `hsl(${hue}, 80%, 58%)`,
          vx: 0, vy: 0, falling: false,
          taken: false
        });
        made++;
      }
    }
    dolls.sort((a,b)=>a.y-b.y);
  }

  makePile(95);

  // ===== Input =====
  const keys = new Set();

  window.addEventListener("keydown", (e) => {
    if (["ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    keys.add(e.key);

    if (e.key === " "){
      if (state.phase !== "play") return;

      if (claw.mode === "idle"){
        if (state.triesLeft <= 0) return;
        state.triesLeft--;
        claw.mode = "downHold";
        claw.targetAngle = cfg.openAngle;
        state.msg = `ë‚´ë ¤ê°€ëŠ” ì¤‘â€¦ (ë‚¨ì€ ${state.triesLeft}) / Spaceë¡œ ì¡ê¸°`;
        state.msgT = 90;
      } else if (claw.mode === "downHold"){
        claw.mode = "grabbing";
        claw.targetAngle = cfg.closedAngle;
        state.msg = "ì¡ëŠ” ì¤‘â€¦";
        state.msgT = 70;
      }
    }
  });

  window.addEventListener("keyup", (e) => keys.delete(e.key));

  canvas.addEventListener("click", (e) => {
    const r = canvas.getBoundingClientRect();
    const mx = (e.clientX - r.left) * (canvas.width / r.width);
    const my = (e.clientY - r.top) * (canvas.height / r.height);
    if (mx>=btn.x && mx<=btn.x+btn.w && my>=btn.y && my<=btn.y+btn.h) resetGame();
  });

  function resetGame(){
    state.phase = "play";
    state.triesLeft = cfg.triesPerStudent;
    state.msg = "â† â†’ ì´ë™ / Space: ë‚´ë ¤ê°€ê¸° â†’ Space: ì¡ê¸°";
    state.msgT = 140;
    state.lastP = 0;
    state.shake = 8;
    state.prize = null;
    state.aim.flash = 0;
    state.aim.idx = null;
    state.aim.result = "";

    claw.x = box.x + box.w/2;
    claw.rope = 0;
    claw.mode = "idle";
    claw.armAngle = cfg.openAngle;
    claw.targetAngle = cfg.openAngle;
    claw.holding = null;
    claw.wiggle = 0;

    makePile(95);
  }

  // ===== Helpers =====
  function tipPos(){
    const bodyY = claw.railY + claw.rope + 14;
    const bodyH = 28;
    return { x: claw.x, bodyY, bodyH, y: bodyY + bodyH + 18 };
  }

  function catchProbability(d){
    const tip = tipPos();
    const dist = Math.hypot(d.x - tip.x, d.y - tip.y);
    const distFactor = clamp(1 - (dist/(d.r+cfg.grabRadiusPad))*cfg.distPenalty, 0, 1);
    const weightFactor = clamp(1 - (d.weight-0.6)*cfg.weightPenalty, 0.10, 1.0);
    const luck = rand(0.92, 1.08);
    return clamp(cfg.baseGrip * distFactor * weightFactor * luck, 0, 0.92);
  }

  function findCandidate(){
    const tip = tipPos();
    let best = null;
    for (let i=0;i<dolls.length;i++){
      const d = dolls[i];
      if (d.taken) continue;
      const dist = Math.hypot(d.x - tip.x, d.y - tip.y);
      const R = d.r + cfg.grabRadiusPad;
      if (dist <= R){
        if (!best || dist < best.dist) best = { i, dist, R };
      }
    }
    return best;
  }

  function tryCatch(){
    const cand = findCandidate();
    if (!cand){
      state.lastP = 0;
      state.aim.idx = null;
      state.aim.result = "NO";
      state.aim.flash = 16;
      return false;
    }

    const idx = cand.i;
    const d = dolls[idx];
    const p = catchProbability(d);
    state.lastP = p;

    // aim HUD data
    const tip = tipPos();
    state.aim.x = tip.x;
    state.aim.y = tip.y;
    state.aim.r = cand.R;
    state.aim.idx = idx;
    state.aim.p = p;

    const ok = Math.random() < p;
    state.aim.result = ok ? "OK" : "NO";
    state.aim.flash = 22;

    if (ok){
      claw.holding = idx;
      d.falling = false; d.vx = 0; d.vy = 0;
      state.shake = 8;
      state.msg = `ì¡í˜! (íŒì • ${Math.round(p*100)}%)`;
      state.msgT = 70;
      return true;
    } else {
      state.msg = `ì‹¤íŒ¨â€¦ (íŒì • ${Math.round(p*100)}%)`;
      state.msgT = 70;
      return false;
    }
  }

  function slipMaybe(){
    if (claw.holding == null) return false;
    const d = dolls[claw.holding];

    const wiggle = Math.abs(Math.sin(claw.wiggle)) * cfg.slipWiggle;
    const weightSlip = clamp((d.weight - 0.7)*0.03, 0, 0.06);
    const pSlip = cfg.slipBase + wiggle + weightSlip;

    if (Math.random() < pSlip){
      // ë–¨ì–´ì§€ê¸° ì‹œì‘ + ì‚´ì§ ì˜†ìœ¼ë¡œ
      d.falling = true;
      d.vx = (Math.random()<0.5 ? -1 : 1) * (0.6 + Math.random()*cfg.slipKickX);
      d.vy = 0.3 + Math.random()*0.8;

      // âœ… ê²½ê³„ ë°–ìœ¼ë¡œ ëª» ë‚˜ê°€ê²Œ ì¦‰ì‹œ í´ë¨í”„
      clampToBox(d);

      claw.holding = null;
      state.msg = "ë¯¸ë„ëŸ¬ì§!!";
      state.msgT = 90;
      state.shake = 10;
      return true;
    }
    return false;
  }

  function clampToBox(d){
    const leftWall = box.x + 12 + d.r;
    const rightWall = box.x + box.w - 12 - d.r;
    const ground = floorY - 2 - d.r;
    d.x = clamp(d.x, leftWall, rightWall);
    d.y = clamp(d.y, box.y + d.r, ground);
  }

  // ===== Update =====
  function update(){
    // msg timer / shake / aim flash
    if (state.msgT>0) state.msgT--;
    if (state.shake>0) state.shake *= 0.90;
    if (state.shake<0.15) state.shake = 0;
    if (state.aim.flash>0) state.aim.flash--;

    // animate claw arms
    claw.armAngle += (claw.targetAngle - claw.armAngle) * cfg.animLerp;

    // move claw
    if (state.phase==="play" && (claw.mode==="idle" || claw.mode==="downHold")){
      if (keys.has("ArrowLeft")) claw.x -= cfg.moveSpeed;
      if (keys.has("ArrowRight")) claw.x += cfg.moveSpeed;
      claw.x = clamp(claw.x, box.x+60, box.x+box.w-60);
    }

    if (state.phase !== "play"){
      stepFalling();
      return;
    }

    if (claw.mode==="downHold"){
      claw.rope += cfg.ropeSpeed;
      claw.rope = clamp(claw.rope, 0, cfg.maxDepth);
      claw.targetAngle = cfg.openAngle;
    }

    if (claw.mode==="grabbing"){
      const closeEnough = Math.abs(claw.armAngle - cfg.closedAngle) < 0.06;
      if (closeEnough){
        tryCatch();
        claw.mode = "up";
      }
    }

    if (claw.mode==="up"){
      claw.wiggle += 0.20;

      if (claw.holding != null){
        slipMaybe();
      }

      claw.rope -= cfg.ropeSpeed;
      claw.rope = clamp(claw.rope, 0, cfg.maxDepth);

      if (claw.rope <= 0){
        claw.rope = 0;
        claw.mode = "opening";
        claw.targetAngle = cfg.openAngle;

        if (claw.holding != null){
          const d = dolls[claw.holding];
          d.taken = true;
          state.prize = { ...d };
          state.phase = "won";
          state.msg = "ì„±ê³µ! ì´ ì¸í˜• 1ê°œ ì§€ê¸‰ ğŸ";
          state.msgT = 999999;
          state.shake = 8;
          claw.holding = null;
        } else {
          if (state.triesLeft === 0){
            state.phase = "done";
            state.msg = "3ë²ˆ ëª¨ë‘ ì‹¤íŒ¨!";
            state.msgT = 999999;
          } else {
            state.msg = "ë‹¤ì‹œ ë„ì „! Spaceë¡œ ë‚´ë ¤ê°€ê³  Spaceë¡œ ì¡ê¸°";
            state.msgT = 140;
          }
        }
      }
    }

    if (claw.mode==="opening"){
      const openEnough = Math.abs(claw.armAngle - cfg.openAngle) < 0.06;
      if (openEnough){
        claw.mode = "idle";
        claw.wiggle = 0;
      }
    }

    // holding doll follow tip
    if (claw.holding != null){
      const d = dolls[claw.holding];
      const tip = tipPos();
      d.falling = false;
      d.vx = 0; d.vy = 0;
      const wig = Math.sin(claw.wiggle) * (6 + d.weight*2);
      d.x = tip.x + wig;
      d.y = tip.y + 14;
      clampToBox(d);
    }

    // ë¯¸ë¦¬ë³´ê¸°(ì¡ê¸° ì „ì—ë„ ë§ì´ ë³´ì´ê²Œ): downHold ìƒíƒœì—ì„œ í›„ë³´ í‘œì‹œ
    if (claw.mode === "downHold"){
      const tip = tipPos();
      const cand = findCandidate();
      state.aim.x = tip.x;
      state.aim.y = tip.y;
      state.aim.idx = cand ? cand.i : null;
      state.aim.r = cand ? cand.R : cfg.grabRadiusPad + 18;
      state.aim.p = cand ? catchProbability(dolls[cand.i]) : 0;
    }

    stepFalling();
  }

  function stepFalling(){
    const leftWall = box.x + 12;
    const rightWall = box.x + box.w - 12;
    const groundY = floorY - 2;

    for (let i=0;i<dolls.length;i++){
      const a = dolls[i];
      if (!a.falling || a.taken) continue;

      a.vy += cfg.g;
      a.vx *= cfg.air;
      a.vy *= cfg.air;

      a.vx = clamp(a.vx, -cfg.maxV, cfg.maxV);
      a.vy = clamp(a.vy, -cfg.maxV, cfg.maxV);

      a.x += a.vx;
      a.y += a.vy;

      // walls (hard clamp)
      if (a.x - a.r < leftWall){
        a.x = leftWall + a.r;
        a.vx *= -cfg.bounce;
      }
      if (a.x + a.r > rightWall){
        a.x = rightWall - a.r;
        a.vx *= -cfg.bounce;
      }

      // ground (hard clamp)
      if (a.y + a.r >= groundY){
        a.y = groundY - a.r;

        if (Math.abs(a.vy) > 0.9){
          a.vy *= -cfg.bounce;
          a.vx *= cfg.groundFriction;
        } else {
          a.vy = 0;
          a.vx *= cfg.groundFriction;
          if (Math.abs(a.vx) < 0.15){
            a.vx = 0;
            a.falling = false;
          }
        }
      }

      // collisions (push a out of overlaps)
      for (let j=0;j<dolls.length;j++){
        if (i===j) continue;
        const b = dolls[j];
        if (b.taken) continue;

        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const dist = Math.hypot(dx,dy);
        const minD = a.r + b.r;

        if (dist > 0 && dist < minD){
          const nx = dx / dist;
          const ny = dy / dist;
          const overlap = (minD - dist);

          a.x += nx * overlap * cfg.collidePush;
          a.y += ny * overlap * cfg.collidePush;

          a.vx += nx * 0.18;
          a.vy += ny * 0.08;

          // âœ… ì¶©ëŒ í›„ì—ë„ ë‹¤ì‹œ ê²½ê³„ í´ë¨í”„(ë°–ìœ¼ë¡œ íŠ€ëŠ” ë²„ê·¸ ë°©ì§€)
          clampToBox(a);
        }
      }

      // ë§ˆì§€ë§‰ ì•ˆì „ í´ë¨í”„
      clampToBox(a);
    }
  }

  // ===== Draw =====
  function draw(){
    const sx = state.shake ? rand(-state.shake, state.shake) : 0;
    const sy = state.shake ? rand(-state.shake, state.shake) : 0;

    ctx.save();
    ctx.translate(sx, sy);

    const bg = ctx.createLinearGradient(0,0,0,H);
    bg.addColorStop(0, "#040615");
    bg.addColorStop(0.6, "#070b1f");
    bg.addColorStop(1, "#03040a");
    ctx.fillStyle = bg;
    ctx.fillRect(-sx,-sy,W,H);

    // frame
    ctx.save();
    ctx.shadowColor = "rgba(80,160,255,.25)";
    ctx.shadowBlur = 18;
    ctx.strokeStyle = "rgba(120,180,255,.30)";
    ctx.lineWidth = 3;
    roundRect(24, 24, W-48, H-48, 18, false, true);
    ctx.restore();

    // glass box
    ctx.save();
    ctx.shadowColor = "rgba(140,210,255,.25)";
    ctx.shadowBlur = 14;
    ctx.strokeStyle = "rgba(140,210,255,.60)";
    ctx.lineWidth = 3;
    roundRect(box.x, box.y, box.w, box.h, 16, false, true);
    ctx.restore();

    // floor line
    ctx.strokeStyle = "rgba(148,163,184,.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(box.x+10, floorY);
    ctx.lineTo(box.x+box.w-10, floorY);
    ctx.stroke();

    // dolls
    for (const d of dolls){
      if (d.taken) continue;
      drawDoll(d);
    }

    // aim ring + candidate highlight
    drawAim();

    // rail
    ctx.save();
    ctx.strokeStyle = "rgba(226,232,240,.80)";
    ctx.lineWidth = 6;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(box.x+10, claw.railY);
    ctx.lineTo(box.x+box.w-10, claw.railY);
    ctx.stroke();
    ctx.restore();

    // rope
    ctx.strokeStyle = "rgba(226,232,240,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(claw.x, claw.railY);
    ctx.lineTo(claw.x, claw.railY + claw.rope + 14);
    ctx.stroke();

    drawClaw();
    drawHUD();
    drawButton();

    if (state.phase==="won" && state.prize) drawPrizeOverlay(state.prize);
    if (state.phase==="done") drawFailOverlay();

    ctx.restore();
  }

  function drawAim(){
    // í‘œì‹œ ì¡°ê±´: ë‚´ë ¤ê°€ëŠ” ì¤‘(downHold) ë˜ëŠ” grabbing ì§í›„ flashê°€ ë‚¨ì•„ìˆì„ ë•Œ
    const show = (claw.mode === "downHold") || (state.aim.flash > 0);
    if (!show) return;

    const x = state.aim.x, y = state.aim.y;
    const R = Math.max(18, state.aim.r || 28);

    // ring
    ctx.save();
    ctx.globalAlpha = (claw.mode==="downHold") ? 0.65 : 0.9;
    ctx.strokeStyle = "rgba(96,165,250,.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, R, 0, Math.PI*2);
    ctx.stroke();

    // center dot
    ctx.fillStyle = "rgba(96,165,250,.9)";
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI*2);
    ctx.fill();

    // candidate highlight
    if (state.aim.idx != null){
      const d = dolls[state.aim.idx];
      if (d && !d.taken){
        ctx.globalAlpha = 0.28;
        ctx.fillStyle = "rgba(96,165,250,.9)";
        ctx.beginPath();
        ctx.arc(d.x, d.y, d.r + 8, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // result flash text
    if (state.aim.flash > 0 && state.aim.result){
      ctx.globalAlpha = 0.95;
      ctx.font = "900 18px system-ui";
      ctx.fillStyle = state.aim.result==="OK" ? "rgba(52,211,153,.95)" : "rgba(248,113,113,.95)";
      const t = state.aim.result==="OK" ? "CATCH!" : "MISS!";
      ctx.fillText(t, x - ctx.measureText(t).width/2, y - R - 10);
    }

    ctx.restore();
  }

  function drawDoll(d){
    ctx.save();
    ctx.shadowColor = d.color;
    ctx.shadowBlur = 16;

    ctx.beginPath();
    ctx.fillStyle = d.color;
    ctx.arc(d.x, d.y, d.r, 0, Math.PI*2);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(d.x - d.r*0.25, d.y - d.r*0.25, d.r*0.55, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = "#0b1022";
    const ex = d.r * 0.28;
    const ey = d.r * 0.12;
    const eyeR = Math.max(2.2, d.r*0.12);
    ctx.beginPath(); ctx.arc(d.x - ex, d.y - ey, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(d.x + ex, d.y - ey, eyeR, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function drawClaw(){
    const tip = tipPos();
    const bodyW = 76, bodyH = 30;
    const bodyX = claw.x - bodyW/2;
    const bodyY = tip.bodyY;

    ctx.save();
    ctx.shadowColor = "rgba(120,180,255,.35)";
    ctx.shadowBlur = 14;
    ctx.fillStyle = "rgba(226,232,240,.92)";
    roundRect(bodyX, bodyY, bodyW, bodyH, 9, true, false);
    ctx.restore();

    ctx.fillStyle = "rgba(226,232,240,.90)";
    ctx.fillRect(claw.x-10, bodyY-10, 20, 10);

    const ax = claw.x, ay = bodyY + bodyH;
    const armLen = 38;
    const a = claw.armAngle;

    ctx.save();
    ctx.strokeStyle = "rgba(226,232,240,.95)";
    ctx.lineWidth = 5;
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(ax - 12, ay);
    ctx.lineTo(ax - 12 - Math.cos(a)*armLen, ay + Math.sin(a)*armLen);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(ax + 12, ay);
    ctx.lineTo(ax + 12 + Math.cos(a)*armLen, ay + Math.sin(a)*armLen);
    ctx.stroke();

    ctx.lineWidth = 4;
    const lx = ax - 12 - Math.cos(a)*armLen;
    const ly = ay + Math.sin(a)*armLen;
    const rx = ax + 12 + Math.cos(a)*armLen;
    const ry = ay + Math.sin(a)*armLen;

    ctx.beginPath();
    ctx.moveTo(lx, ly);
    ctx.lineTo(lx + 9, ly + 11);
    ctx.moveTo(rx, ry);
    ctx.lineTo(rx - 9, ry + 11);
    ctx.stroke();

    ctx.restore();
  }

  function drawHUD(){
    ctx.fillStyle = "rgba(226,232,240,.95)";
    ctx.font = "18px system-ui";
    ctx.fillText(`ë‚¨ì€ ì‹œë„: ${state.triesLeft}`, 34, 50);

    ctx.fillStyle = "rgba(148,163,184,.90)";
    ctx.font = "14px system-ui";
    ctx.fillText(`ë§ˆì§€ë§‰ íŒì •: ${Math.round(state.lastP*100)}%`, 34, 72);

    ctx.fillStyle = "rgba(203,213,225,.80)";
    ctx.font = "14px system-ui";
    ctx.fillText("â† â†’ ì´ë™ / Space: ë‚´ë ¤ê°€ê¸° â†’ Space: ì¡ê¸°", 34, H-28);

    if (state.msgT>0 || state.phase!=="play"){
      ctx.fillStyle = "rgba(203,213,225,.85)";
      ctx.font = "14px system-ui";
      ctx.fillText(state.msg, 34, 92);
    }
  }

  function drawButton(){
    ctx.save();
    ctx.shadowColor = "rgba(80,160,255,.25)";
    ctx.shadowBlur = 14;

    ctx.fillStyle = "rgba(15,23,42,.72)";
    roundRect(btn.x, btn.y, btn.w, btn.h, 999, true, false);

    ctx.strokeStyle = "rgba(120,180,255,.35)";
    ctx.lineWidth = 2;
    roundRect(btn.x, btn.y, btn.w, btn.h, 999, false, true);

    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(226,232,240,.92)";
    ctx.font = "800 16px system-ui";
    const t = "ë‹¤ìŒ í•™ìƒ (RESET)";
    const tw = ctx.measureText(t).width;
    ctx.fillText(t, btn.x + btn.w/2 - tw/2, btn.y + 30);

    ctx.restore();
  }

  function drawPrizeOverlay(p){
    ctx.save();
    ctx.globalAlpha = 0.68;
    ctx.fillStyle = "#000";
    ctx.fillRect(box.x, box.y, box.w, box.h);
    ctx.globalAlpha = 1;

    const cw = 540, ch = 250;
    const cx = W/2 - cw/2, cy = box.y + box.h/2 - ch/2;

    ctx.fillStyle = "rgba(10,12,20,.88)";
    roundRect(cx, cy, cw, ch, 18, true, false);
    ctx.strokeStyle = "rgba(120,180,255,.35)";
    ctx.lineWidth = 2;
    roundRect(cx, cy, cw, ch, 18, false, true);

    ctx.shadowColor = p.color;
    ctx.shadowBlur = 28;
    ctx.beginPath();
    ctx.fillStyle = p.color;
    ctx.arc(cx + 130, cy + 125, 64, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.fillStyle = "#0b1022";
    ctx.beginPath(); ctx.arc(cx+130-18, cy+115, 6, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx+130+18, cy+115, 6, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(226,232,240,.95)";
    ctx.font = "900 26px system-ui";
    ctx.fillText("ë‹¹ì²¨ ì¸í˜•!", cx + 250, cy + 90);

    ctx.fillStyle = "rgba(203,213,225,.9)";
    ctx.font = "16px system-ui";
    ctx.fillText("ì´ í™”ë©´ì„ ë³´ì—¬ì£¼ê³  ì‹¤ì œ ì¸í˜• 1ê°œë¥¼ ì§€ê¸‰í•˜ì„¸ìš”.", cx + 250, cy + 130);
    ctx.fillText("ë‹¤ìŒ í•™ìƒì€ ì•„ë˜ RESET ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.", cx + 250, cy + 160);

    ctx.restore();
  }

  function drawFailOverlay(){
    ctx.save();
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "#000";
    ctx.fillRect(box.x, box.y, box.w, box.h);
    ctx.globalAlpha = 1;

    ctx.fillStyle = "rgba(248,113,113,.95)";
    ctx.font = "900 30px system-ui";
    const t = "3ë²ˆ ëª¨ë‘ ì‹¤íŒ¨!";
    ctx.fillText(t, W/2 - ctx.measureText(t).width/2, box.y + box.h/2 - 8);

    ctx.fillStyle = "rgba(203,213,225,.90)";
    ctx.font = "16px system-ui";
    const t2 = "RESET ë²„íŠ¼ì„ ëˆŒëŸ¬ ë‹¤ìŒ í•™ìƒìœ¼ë¡œ ë„˜ì–´ê°€ì„¸ìš”.";
    ctx.fillText(t2, W/2 - ctx.measureText(t2).width/2, box.y + box.h/2 + 26);

    ctx.restore();
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // ===== Loop =====
  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>
